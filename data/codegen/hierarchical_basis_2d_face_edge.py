#!/usr/bin/env python3

import numpy as np
import scipy.special
from sympy import *
import sys

x, y = symbols('x y')

DEGREE = 7
MINLEVEL = 4
MAXLEVEL = 8

monomials = []

def getNumCoefficientsForDegree(degree):
  return int(scipy.special.binom(2 + degree - 1, degree))

for d in range(DEGREE+1):
  i = d
  j = 0

  for k in range(getNumCoefficientsForDegree(d)):
    monomials.append(x**i * y**j)
    i -= 1
    j += 1

def polynomial(coeffs):
  out = 0.0
  for coeff,monomial in zip(coeffs, monomials):
    out += coeff * monomial

  out = horner(out)
    
  return out

def plambda(polynomial):
  return lambdify((x,y), polynomial, "numpy")

num_coefficients = len(monomials)

coordmemory = {}
def coords(level):

  if level in coordmemory:
    return coordmemory[level]
  else:

    num_vertices = int((2**level) * (2**level + 1) / 2) - 2**level - 1
    rowsize = 2**level + 1

    xvec = np.zeros(num_vertices)
    yvec = np.zeros(num_vertices)

    h = 1.0 / (rowsize-1)

    offset = 0
    for i in range(rowsize-3):
        for j in range(rowsize-2-i):
          xvec[offset] = j * h + 0.5 * h
          yvec[offset] = i * h + h
          offset += 1

    coordmemory[level] = (xvec, yvec)
    return coordmemory[level]

def orthogonalize(level):

  basis = np.eye(num_coefficients)

  def scalarproduct(lhs, rhs):
    lhs_poly = plambda(polynomial(lhs))
    rhs_poly = plambda(polynomial(rhs))

    xvec, yvec = coords(level)

    lhsvec = lhs_poly(xvec, yvec)
    rhsvec = rhs_poly(xvec, yvec)

    if type(lhsvec) == float:
      lhsvec = lhsvec * np.ones(len(xvec))

    if type(rhsvec) == float:
      rhsvec = rhsvec * np.ones(len(xvec))

    return np.dot(lhsvec, rhsvec)

  # Orthogonalization
  basis[0,:] = 1.0 / np.sqrt(scalarproduct(basis[0,:], basis[0,:])) * basis[0,:]

  for i in range(1, num_coefficients):
    for j in range(i):
      c = scalarproduct(basis[j,:], basis[i,:])
      basis[i,:] = basis[i,:] - c * basis[j,:]

    basis[i,:] = 1.0 / np.sqrt(scalarproduct(basis[i,:], basis[i,:])) * basis[i,:]

  # Test if basis is really orthogonal
  if level == MINLEVEL:
    test = np.zeros((num_coefficients,num_coefficients))

    for i in range(num_coefficients):
      for j in range(num_coefficients):
        test[i,j] = scalarproduct(basis[i,:], basis[j,:])

    testval = np.sum(np.sum(test))

    if abs(testval-num_coefficients) > 1e-3:
      sys.stderr.write('Could not find orthogonal basis for level {}'.format(level))
      sys.exit(-1)

  return basis

# Generate code
x.name = 'x[0]'
y.name = 'x[1]'


print('#pragma once\n')
print('// This file was generated by the hierarchical_basis_2d_face_edge.py Python script')
print('// Do not edit it by hand\n')
print('namespace hhg {\n')
print('class HierarchicalBasis {')
print('public:')

print('  static real_t eval(uint_t level, uint_t basis, const Point2D &x) {')
print('    switch(level) {')

for level in range(MINLEVEL, MAXLEVEL+1):
  print('      case {}:'.format(level))

  print('        switch(basis) {')

  basis = orthogonalize(level)

  for i in range(num_coefficients):
    print('          case {}:'.format(i))

    poly = polynomial(basis[i,:])

    print('            return {};'.format(ccode(poly)))

  print('          default:')
  print('            WALBERLA_ABORT("Polynomial basis " << basis << " was not generated");')

  print('      }')


print('      default:')
print('        WALBERLA_ABORT("Polynomials for level " << level << " were not generated");')

print('    }')
print('  }')


print('};')

print('}')
