#!/usr/bin/env python3

import numpy as np
import scipy.special
from sympy import *
from enum import Enum
import sys

x, y = symbols('x y')

DEGREE = 7
MINLEVEL = 4
MAXLEVEL = 6

class EdgeDir(Enum):
  HORI = 1
  VERT = 2
  DIAG = 3

monomials = []

def getNumCoefficientsForDegree(degree):
  return int(scipy.special.binom(2 + degree - 1, degree))

for d in range(DEGREE+1):
  i = d
  j = 0

  for k in range(getNumCoefficientsForDegree(d)):
    monomials.append(x**i * y**j)
    i -= 1
    j += 1

def polynomial(coeffs):
  out = 0.0
  for coeff,monomial in zip(coeffs, monomials):
    out += coeff * monomial

  out = horner(out)
    
  return out

def plambda(polynomial):
  return lambdify((x,y), polynomial, "numpy")

num_coefficients = len(monomials)

coordmemory = {}
def coords(level, edgedir):

  if (level, edgedir) in coordmemory:
    return coordmemory[(level, edgedir)]
  else:

    num_vertices = int((2**level) * (2**level + 1) / 2) - 2**level - 1
    rowsize = 2**level + 1

    xvec = np.zeros(num_vertices)
    yvec = np.zeros(num_vertices)

    h = 1.0 / (rowsize-1)

    if edgedir == EdgeDir.HORI:

      offset = 0
      for i in range(rowsize-3):
          for j in range(rowsize-2-i):
            xvec[offset] = j * h + 0.5 * h
            yvec[offset] = i * h + h
            offset += 1

    if edgedir == EdgeDir.VERT:
      offset = 0
      for i in range(rowsize-3):
          for j in range(rowsize-2-i):

            if j != rowsize-2-i-1:
              xvec[offset] = j * h + h
              yvec[offset] = i * h + 0.5 * h
            else:
              xvec[offset] = j * h
              yvec[offset] = i * h + 0.5 * h + h

            offset += 1

    coordmemory[(level, edgedir)] = (xvec, yvec)
    return coordmemory[(level, edgedir)]

def orthogonalize(level, edgedir):

  basis = np.eye(num_coefficients)

  def scalarproduct(lhs, rhs):
    lhs_poly = plambda(polynomial(lhs))
    rhs_poly = plambda(polynomial(rhs))

    xvec, yvec = coords(level, edgedir)

    lhsvec = lhs_poly(xvec, yvec)
    rhsvec = rhs_poly(xvec, yvec)

    if type(lhsvec) == float:
      lhsvec = lhsvec * np.ones(len(xvec))

    if type(rhsvec) == float:
      rhsvec = rhsvec * np.ones(len(xvec))

    return np.dot(lhsvec, rhsvec)

  # Orthogonalization
  basis[0,:] = 1.0 / np.sqrt(scalarproduct(basis[0,:], basis[0,:])) * basis[0,:]

  for i in range(1, num_coefficients):
    for j in range(i):
      c = scalarproduct(basis[j,:], basis[i,:])
      basis[i,:] = basis[i,:] - c * basis[j,:]

    basis[i,:] = 1.0 / np.sqrt(scalarproduct(basis[i,:], basis[i,:])) * basis[i,:]

  # Test if basis is really orthogonal
  if level == MINLEVEL:
    test = np.zeros((num_coefficients,num_coefficients))

    for i in range(num_coefficients):
      for j in range(num_coefficients):
        test[i,j] = scalarproduct(basis[i,:], basis[j,:])

    testval = np.sum(np.sum(test))

    if abs(testval-num_coefficients) > 1e-3:
      sys.stderr.write('Could not find orthogonal basis for level {}'.format(level))
      sys.exit(-1)

  return basis

# Generate code
x.name = 'x[0]'
y.name = 'x[1]'

def generate(edgedir, name):
  print('class {} {{'.format(name))
  print('public:')

  print('  static real_t eval(uint_t level, uint_t basis, const Point2D &x) {')
  print('    switch(level) {')

  for level in range(MINLEVEL, MAXLEVEL+1):
    print('      case {}:'.format(level))

    print('        switch(basis) {')

    basis = orthogonalize(level, edgedir)

    for i in range(num_coefficients):
      print('          case {}:'.format(i))

      poly = polynomial(basis[i,:])

      print('            return {};'.format(ccode(poly)))

    print('          default:')
    print('            WALBERLA_ABORT("Polynomial basis " << basis << " was not generated");')

    print('      }')


  print('      default:')
  print('        WALBERLA_ABORT("Polynomials for level " << level << " were not generated");')

  print('    }')
  print('  }')


  print('};\n')


print('#pragma once\n')
print('// This file was generated by the hierarchical_basis_2d_face_edge.py Python script')
print('// Do not edit it by hand\n')
print('namespace hhg {\n')

generate(EdgeDir.HORI, 'HorizontalEdgeBasis')
generate(EdgeDir.VERT, 'VerticalEdgeBasis')

print('}')
